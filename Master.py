# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Master.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets ,QtTest
from PyQt5.QtCore import Qt , QPoint,pyqtSignal
import Master_or_Client
import pywifi
import re
import subprocess
import time
from threading import Thread
import Master_GUI
import socket
import json
from graphviz import Digraph
import os
import shutil
from PIL import Image
class master_Form(QtWidgets.QWidget, Master_GUI.Ui_Form_master):
    tree_show_signal       = pyqtSignal()
    clear_text_signal      = pyqtSignal()
    chat_show_signal       = pyqtSignal(str)
    room_show_signal       = pyqtSignal(str)
    program_state_signal   = pyqtSignal(str)
    state_change_signal    = pyqtSignal(str,str)
    def __init__(self, parent=None):
        super(master_Form, self).__init__(parent)
        self.setupUi(self)
        #Center the window
        qr = self.frameGeometry()
        cp = QtWidgets.QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())        
        self.setWindowTitle("ChainSpoT")
        self.setWindowIcon(QtGui.QIcon("Icons/logo.png"))
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        self.oldPos = self.pos()
        self.setWindowFlag(Qt.FramelessWindowHint) #Hide the title bar of window
        self.pushButton_6.clicked.connect(self.master_or_client)
        self.bn_close.clicked.connect(self.exit)
        self.bn_min.clicked.connect(self.showMinimized)
        self.checkBox_2.toggled.connect(self.show_hide_pass)
        self.pushButton_3.hide()
        self.pushButton.clicked.connect(self.start)
        self.pushButton_2.clicked.connect(self.stop)
        self.Master.setTabEnabled(1,False)
        self.Master.setTabEnabled(2,False)
        self.Master.setTabEnabled(3,False)
        self.profile_name=""
        self.plainTextEdit.setReadOnly(True)
        self.pushButton_4.clicked.connect(self.on_enter_key_pressed)
        self.plainTextEdit_2.installEventFilter(self)
        self.stop_threads = False

        t5 = Thread(target = self.interface_scan, args = () )
        t5.start()

        t6 = Thread(target = self.room_timer_check, args = () )
        t6.start()
        self.tree_show_signal.connect(self.tree_show)
        self.chat_show_signal.connect(self.chat_show)
        self.clear_text_signal.connect(self.clear_text)
        self.room_show_signal.connect(self.room_show)
        self.program_state_signal.connect(self.program_state)
        self.state_change_signal.connect(self.state_change)
        self.tree=[]
        
#####################################Server Mangement#########################################################################        
    
    def server_run(self):
       self.clients_list = []
       self.last_received_message = ""
       self.server_socket = None
       self.create_listening_server()
        
    #listen for incoming connection
    def create_listening_server(self):
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #create a socket using TCP port and ipv4
        local_ip = '192.168.0.2'
        local_port = 10319
        # this will allow you to immediately restart a TCP server
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # this makes the server listen to requests coming from other computers on the network
        self.server_socket.bind((local_ip, local_port))
        print("Listening for incoming messages..")
        self.server_socket.listen(100) #listen for incomming connections / max 100 clients
        self.receive_messages_in_a_new_thread()

    def receive_messages_in_a_new_thread(self):
        while True:
            try:
                client = so, (ip, port) = self.server_socket.accept()
            except Exception as e: #socket.error as e:
                print(str(e))
                if ("An operation was attempted on something that is not a socket" in str(e) or "An invalid argument was supplied" in str(e) ):
                        print("Error ! ")
                        for client in self.clients_list:
                            socket, (ip, port) = client 
                            socket.close()  
                        return
                print("WoW Error ! "+str(e))
                return
            self.add_to_clients_list(client)
            print('Connected to ', ip, ':', str(port))
            t =Thread(target=self.receive_messages, args=(client,))
            t.start()
    
    #fun to receive new msgs
    def receive_messages(self, client):
        so, (ip, port) = client 
        incoming_buffer=""
        while True:
            try:
                incoming_buffer = so.recv(1024) #initialize the buffer
            except Exception as e: #socket.error as e:
                if "An established connection was aborted by the software in your host machine" in str(e) :
                    self.tree_thread_stop = 1
                    self.delete_from_clients_list(client) 
                    print("sockerr1"+str(e))
                    return
                if "An existing connection was forcibly closed by the remote host" in str(e):
                    self.delete_from_clients_list(client)
                    print("sockerr2"+str(e)) 
                    return
                else:
                        print("new")
                        print(e)     
                        

            if not incoming_buffer :
                break
            
            self.last_received_message = incoming_buffer.decode('utf-8')
            self.broadcast_to_all_clients(so)  # send to all clients
        print("close")
        so.close()

    #broadcast the message to all clients 
    def broadcast_to_all_clients(self, senders_socket):
        for client in self.clients_list:
            socket, (ip, port) = client
            if socket is not senders_socket :
                socket.sendall(self.last_received_message.encode('utf-8'))
                

    #add a new client 
    def add_to_clients_list(self, client):
        if client not in self.clients_list:
            self.clients_list.append(client)

    #delete a client 
    def delete_from_clients_list(self, client):
        for i in self.clients_list:
            if i == client:
                self.clients_list.remove(i)
            

    def room_timer_check(self):
        while True:
            if (self.stop_threads):
                break
            power,id_list,room_list,comp_id =self.parse_wifi()
            self.room_show_signal.emit(str( list(dict.fromkeys(room_list)) ).replace(","," , ").replace("[","").replace("]",""))
            time.sleep(2)
    
########################################################################################################################################   

#########################################Client Mangement###############################################################################
    def client_run(self):
        self.initialize_socket()
        self.listen_for_incoming_messages_in_a_thread()
        self.on_join()
        

    def initialize_socket(self):
        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # initialazing socket with TCP and IPv4
        remote_ip = '192.168.0.2' # IP address 
        remote_port = 10319 #TCP port
        self.client_socket.connect((remote_ip, remote_port)) #connect to the remote server
      
    def listen_for_incoming_messages_in_a_thread(self):
        thread = Thread(target=self.receive_message_from_server, args=(self.client_socket,)) # Create a thread for the send and receive in same time 
        thread.start()
        
    #function to recieve msg
    def receive_message_from_server(self, so):
        buffer=""
        while True:
            try:
                buffer = so.recv(1024)
            except Exception as e: # socket.error as e:
                if "An established connection was aborted by the software in your host machine" in str(e) or "An existing connection was forcibly closed by the remote host" in str(e) :
                        return
                else:
                        print("new")
                        print(e)
                     
            if not buffer:
                break
            message = buffer.decode('utf-8')
            if '{"parent": 'in message:
                message = json.loads(message)
                self.add_to_tree(message)
                continue

            if "joined" in message:
                user = message.split(":")[1]
                message = user + " has joined"

            self.chat_show_signal.emit(message)
        so.close()

    def on_join(self):
        #put hotspot name
        self.client_socket.send(("joined:" + self.master_ID).encode('utf-8'))
        self.tree_thread_stop = 0
        tree_thread = Thread(target=self.tree_send, args=()) # Create a thread for the send and receive in same time 
        tree_thread.start()

    def eventFilter(self, obj, event):
        
        if obj is self.plainTextEdit_2 and event.type() == QtCore.QEvent.KeyPress:
            modifiers = QtWidgets.QApplication.keyboardModifiers()
            if modifiers != QtCore.Qt.ShiftModifier: #This condition to prevent Shift + Enter from sending messages, it will just make new line and move cursor to it (The normal case)
                if event.key() in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter):
                    print(event.key() == QtCore.Qt.Key_Return)
                    self.on_enter_key_pressed()
                    return True
        return super(master_Form, self).eventFilter(obj, event)


    def on_enter_key_pressed(self):
        self.send_chat()
        self.clear_text_signal.emit()
    
    def clear_text(self):
        self.plainTextEdit_2.setPlainText("")

    def send_chat(self):
        senders_name = self.master_ID + ": "
        data = self.plainTextEdit_2.toPlainText().strip()
        message = (senders_name + data).encode('utf-8')
        self.chat_show_signal.emit(message.decode('utf-8'))
        self.client_socket.send(message)
        return 'break'

    def mov_bin(self):
        cwd = os.getcwd()
        mwd = os.path.join(cwd, "Graphviz","bin")
        allfiles = os.listdir(mwd)
        for file in allfiles:
            shutil.copy(os.path.join(mwd,file),os.path.join(cwd,file))
        return allfiles

    def delete_bin(self,allfiles):   
        for file in allfiles:
            if os.path.exists(file):
                os.remove(file)
    
    def add_to_tree(self, leaf):
        for i in self.tree:
            if i["hotspot_name"] == leaf["hotspot_name"]:
                self.tree.remove(i)
        self.tree.append(leaf)
    
    def room_show(self,rooms):
        if self.stop_threads == 0:
            self.label_26.setText(rooms)

    def chat_show(self,message):
        self.plainTextEdit.insertPlainText(message + '\n')
        scrollIsAtEnd = self.plainTextEdit.verticalScrollBar().maximum() - self.plainTextEdit.verticalScrollBar().value()
        if (scrollIsAtEnd):
            self.plainTextEdit.verticalScrollBar().setValue(self.plainTextEdit.verticalScrollBar().maximum())            
    
    def tree_show(self):
        self.tree_photo.setAlignment(Qt.AlignCenter)
        self.statistics_photo.setAlignment(Qt.AlignCenter)
        self.tree_photo.setPixmap(QtGui.QPixmap("tree.png"))
        self.statistics_photo.setPixmap(QtGui.QPixmap("statistics.png"))

    def tree_send(self):
        while True:
                if self.tree_thread_stop == 1:
                        break
                time_now = int(time.time())
                for i in self.tree:
                    if time_now - int(i["time"]) > 100:
                        self.tree.remove(i)
                try:
                    cmd_output = subprocess.check_output("ping 192.168.0.2", shell=True).decode()
                    loss_regex = re.compile(r'\d+%')
                    temp       = loss_regex.search(cmd_output)
                    loss       = temp.group()
                    cmd_output = cmd_output.split("\n")[-2]
                    if "Average" in cmd_output:
                        cmd_output = cmd_output.replace("\r","")
                        cmd_output = cmd_output.replace(" ","")
                        cmd_output = cmd_output.split("=")
                        ping       = cmd_output[-1]
                    else:
                        ping       = ""
                        loss       = "100%"
                except subprocess.CalledProcessError as e:
                    print(e.output)
                    ping       = "error"
                    loss       = "error"

                if self.tree_thread_stop == 1:
                        break
                myleaf ={
                "parent": "",
                "wifi_ip": "",
                "hotspot_name": self.master_ID,
                "loss":loss,
                "ping": ping,
                "time":str(int(time.time()))
                }
                
                data = json.dumps(myleaf)
                self.add_to_tree(myleaf)
                # instantiating object
                dot_tree = Digraph(comment='A Round Graph')
                dot_statistics = Digraph(comment='A Round Graph')
                for key in self.tree:
                    dot_tree.node(str(self.tree.index(key) ),key["hotspot_name"])
                    dot_statistics.node(str(self.tree.index(key) ),"Node name: "+key["hotspot_name"]+"\nNode IP: "+key["wifi_ip"]+"\nLoss "+key["loss"]+"\nPing "+key["ping"])


                # Adding edges
                a = []
                for key in self.tree:
                    for i in self.tree:
                        if key["parent"] == i["hotspot_name"]:
                            a.append(f'{self.tree.index(i)}{self.tree.index(key)}')
                print(self.tree)
                self.tree = []
                dot_tree.edges(a)
                dot_statistics.edges(a)

                # saving images
                dot_tree.format = 'png'
                dot_statistics.format = 'png'
                allfiles = self.mov_bin()
                dot_statistics.render("statistics", view = False)
                dot_tree.render("tree", view = False)
                image = Image.open("statistics.png")
                temp =image.resize((900,350))
                temp.save("statistics.png")
                self.tree_show_signal.emit()
                self.delete_bin(allfiles)
                self.client_socket.sendall(bytes(data,encoding="utf-8"))
                time.sleep(50)

########################################################################################################################################
    #it's return list of spot ID which contain rooms and computer ID return
    def parse_wifi(self):
        power=self.power_wifi()
        networks= list(power.keys())
        r = re.compile("\d+\.\d+\.\d+")
        id_list = list(filter(r.match, networks))
        room_list = []
        comp_id=[]
        if id_list: #Bug we can remove "if id_list" for loop will do this check for us 
           for i in id_list:
              room_list.append(int(i.split(".")[0]))
              comp_id.append(int(i.split(".")[1]))
        return power , id_list, sorted(room_list) , sorted(comp_id)

    #return dictionary {key:value} key is network SSID , value is percentage of SSID Power ex: 30,70,80,99
    def power_wifi(self,power = {},prev_check=0):
        if prev_check==0:
                power = {}
        try:
            cmd_output = subprocess.check_output("netsh wlan SHOW NETWORKS MODE=BSSID", shell=True)
        except subprocess.CalledProcessError as e:
            print(e.output)
            return power
        cmd_output = cmd_output.decode()
        cmd_output = cmd_output.replace("\r","")
        list_output = cmd_output.split("\n")
        list_output = list_output[4:]
        count = 0
        while count < len(list_output):
           if "SSID" in list_output[count] and list_output[count][9:].strip() != ""  :
                #Bug count + 5 list index out of range when connecting to wifi Signal element not exist
                try:
                   if "Signal" in list_output[count+5]:     
                        power[list_output[count][9:].strip()]=int(''.join(list(filter(str.isdigit, list_output[count+5]))))
                except:
                   pass
           count += 1
        if  prev_check == 0 :          
                QtTest.QTest.qWait(4000)
                return self.power_wifi(power,1)   
        else:
                return power

    # "netsh wlan SHOW NETWORKS" command not actually re-scan the available wifi networks , it's just show the cash of the last scanning operation
    #in this function we re-scan the wifi interface by pywifi library   Interface.scan()
    def interface_scan(self):
        wifi = pywifi.PyWiFi()
        iface = wifi.interfaces()[0]
        while True:
                if (self.stop_threads):
                        break
                print("i1")
                iface.scan()
                time.sleep(6)

    def program_state(self,txt):
        self.label_15.setText(txt)
    
    def state_change(self,master_ID,room_ID):
        self.lab_user.setText(master_ID)
        self.label_19.setText(master_ID)
        self.label_17.setText(room_ID)
        if(master_ID == ""):
            self.lab_user_2.setStyleSheet("color:rgb(138, 11, 49);")
            self.lab_user_2.setText("OFF")
            self.label_22.setText("OFF")
            self.pushButton_3.hide()
            self.pushButton.setEnabled(True)
            self.pushButton_2.setEnabled(False)
            self.Master.setTabEnabled(1,False)
            self.Master.setTabEnabled(2,False)
            self.Master.setTabEnabled(3,False)
        else:
            self.lab_user_2.setStyleSheet("color:rgb(50,205,50);")
            self.lab_user_2.setText("ON")
            self.label_22.setText("ON")
            self.pushButton_3.show()
            self.pushButton.setEnabled(False)
            self.pushButton_2.setEnabled(True)
            self.Master.setTabEnabled(1,True)
            self.Master.setTabEnabled(2,True)
            self.Master.setTabEnabled(3,True)
        
    
    def start(self):
        self.program_state_signal.emit("                   Trying To Start ChainSpoT Network ...")
        power,id_list,room_list,comp_id =self.parse_wifi()
        if room_list:
                room_ID = str(room_list[-1]+1)
                self.master_ID = room_ID+".0.0"
                check=self.start_hotspot(self.master_ID,self.lineEdit.text())
        else:
                room_ID = "1"
                self.master_ID = room_ID+".0.0"
                check=self.start_hotspot(self.master_ID,self.lineEdit.text())
        if check and self.check_hotspot() == True:
                self.program_state_signal.emit("               ChainSpoT Network Start Successfully")
                self.state_change_signal.emit(self.master_ID,room_ID)
                self.t_server = Thread(target = self.server_run )
                self.t_server.start()
                self.t_client = Thread(target = self.client_run )
                self.t_client.start()  
        
        else:
                self.program_state_signal.emit("                    Failed To Start ChainSpoT Network")
                


    def stop(self):
        self.program_state_signal.emit("                  Trying To Stop ChainSpoT Network ...")
        check = self.stop_hotspot()
        if check and self.check_hotspot() == False:
                self.program_state_signal.emit("                 ChainSpoT Network Stop Successfully")
                self.state_change_signal.emit("","")
                #Stop client and server
                self.client_socket.close()
                self.server_socket.close()
               
        else:
                self.program_state_signal.emit("                   Failed To Stop ChainSpoT Network")

    def run(self,cmd):
        try:
            self.completed =subprocess.run(["powershell", "-Command", cmd], capture_output=True)
        except subprocess.CalledProcessError as e:
            print(e.output)
            return -1
        return self.completed

    #check if you open hotspot or not return True or False
    def check_hotspot(self,prev_check=0):
       if self.profile_name =="":
               return -1
       power_shell_cmd='''$connectionProfile = [Windows.Networking.Connectivity.NetworkInformation,Windows.Networking.Connectivity,ContentType=WindowsRuntime]::GetConnectionProfiles()
foreach($i in $connectionProfile){
if ( $i.profileName -eq ''' +"'" +self.profile_name+ "'"+''' )
{
$profileName =$i 
}
}
$tetheringManager = [Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager,Windows.Networking.NetworkOperators,ContentType=WindowsRuntime]::CreateFromConnectionProfile($profileName)
$tetheringManager.TetheringOperationalState
    '''
       power_shell_output = self.run(power_shell_cmd)
       power_shell_output = power_shell_output.stdout.decode()
       power_shell_output = power_shell_output.replace("\r","")
       power_shell_output = power_shell_output.replace("\n","")
     
       if power_shell_output =="InTransition" and prev_check == 0 :
          QtTest.QTest.qWait(5000)
          return self.check_hotspot(1) 
       elif power_shell_output == "On":
          return True
       elif power_shell_output == "Off":
          return False
       else:
          return -1

    #start hotspot networf if it works return True else return False
    #input only hotspot name and password of hotspot
    def start_hotspot(self,hotspot_name,password):

       if len(password) <8 or len(password) > 32 or'"' in password: #If password less than 8 char or bigger than 32 char or there's double quote in password retturn -1
          return -1

       self.power_shell_cmd= '''Add-Type -AssemblyName System.Runtime.WindowsRuntime
$asTaskGeneric = ([System.WindowsRuntimeSystemExtensions].GetMethods() | ? { $_.Name -eq 'AsTask' -and $_.GetParameters().Count -eq 1 -and $_.GetParameters()[0].ParameterType.Name -eq 'IAsyncOperation`1' })[0]
Function Await($WinRtTask, $ResultType) {
    $asTask = $asTaskGeneric.MakeGenericMethod($ResultType)
    $netTask = $asTask.Invoke($null, @($WinRtTask))
    $netTask.Wait(-1) | Out-Null
    $netTask.Result
}
Function AwaitAction($WinRtAction) {
    $asTask = ([System.WindowsRuntimeSystemExtensions].GetMethods() | ? { $_.Name -eq 'AsTask' -and $_.GetParameters().Count -eq 1 -and !$_.IsGenericMethod })[0]
    $netTask = $asTask.Invoke($null, @($WinRtAction))
    $netTask.Wait(-1) | Out-Null
}
$connectionProfile = [Windows.Networking.Connectivity.NetworkInformation,Windows.Networking.Connectivity,ContentType=WindowsRuntime]::GetConnectionProfiles()
foreach($i in $connectionProfile){
if ( $i.profileName -eq "Ethernet 2" )
{
$profileName =$i 
}

}
$tetheringManager = [Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager,Windows.Networking.NetworkOperators,ContentType=WindowsRuntime]::CreateFromConnectionProfile($profileName)
$accessPointConfiguration = $tetheringManager.GetCurrentAccessPointConfiguration()
$accessPointConfiguration.Ssid = ''' + '"'+ hotspot_name+'"'+" \n$accessPointConfiguration.Passphrase ="+'"'+password+'"' +''' \nAwaitAction ($tetheringManager.ConfigureAccessPointAsync($accessPointConfiguration)) ([Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult])
Await ($tetheringManager.StartTetheringAsync()) ([Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult])
Write-Output $profileName.profileName
'''
    
       self.power_shell_output = self.run(self.power_shell_cmd)
       if self.power_shell_output.returncode != 0:
          #print("An error occured: %s", completed.stderr) # Just if You want to print the error
          return False

       self.power_shell_output = self.power_shell_output.stdout.decode()
       self.power_shell_output = self.power_shell_output.replace("\r","")
       self.power_shell_output = self.power_shell_output.split("\n")
       for i in range(len(self.power_shell_output)):
               if "Success" in self.power_shell_output[i]:
                       self.profile_name=self.power_shell_output[i+1]
                       return True
       return False

    #check if you open hotspot or not then stop hotspot network if it done return True else return False
    #input only hotspot name and password of hotspot
    def stop_hotspot(self):
       if self.profile_name =="":
               return -1
       power_shell_cmd='''$connectionProfile = [Windows.Networking.Connectivity.NetworkInformation,Windows.Networking.Connectivity,ContentType=WindowsRuntime]::GetConnectionProfiles()
foreach($i in $connectionProfile){
if ( $i.profileName -eq ''' +"'" +self.profile_name+ "'"+''' )
{
$profileName =$i 
}
}       
$tetheringManager = [Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager,Windows.Networking.NetworkOperators,ContentType=WindowsRuntime]::CreateFromConnectionProfile($profileName)
$tetheringManager.StopTetheringAsync()
'''
       power_shell_output = self.run(power_shell_cmd)
       check = self.check_hotspot()
       if check == False:
        return True 
       elif check == True:
        return False
       else:
        return -1

    def show_hide_pass(self):
        if self.checkBox_2.isChecked():
           self.lineEdit.setEchoMode(QtWidgets.QLineEdit.Normal)
        else:
           self.lineEdit.setEchoMode(QtWidgets.QLineEdit.Password)

    def exit(self):
        self.stop_threads=True
        self.close() 

    def master_or_client(self):
        self.stop_threads=True
        self.w = Master_or_Client.master_or_client_Form()
        self.w.show()
        self.close()

    def mousePressEvent(self, event):
        self.oldPos = event.globalPos()

    def mouseMoveEvent(self, event):
        delta = QPoint (event.globalPos() - self.oldPos)
        self.move(self.x() + delta.x(), self.y() + delta.y())
        self.oldPos = event.globalPos()







if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    master = master_Form()
    master.show()
    sys.exit(app.exec_())
