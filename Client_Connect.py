# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Client_Connect.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from threading import Thread
from traceback import print_tb
from PyQt5 import QtCore, QtGui, QtWidgets,QtTest
from PyQt5.QtCore import Qt, QPoint,pyqtSignal 
import Client
import pywifi
import subprocess
import re
import os
import time
import Client_Connect_GUI


class client_Connect_Form(QtWidgets.QWidget, Client_Connect_GUI.Ui_Form_client_Connect):
    chain_show_signal         = pyqtSignal(list,dict)   
    connected_show_signal     = pyqtSignal(int)
    failed_show_signal        = pyqtSignal(int)
    trying_show_signal        = pyqtSignal(int)
    
    def __init__(self, room_ID=1,password="",parent=None):
        self.room_ID=room_ID
        self.password=password
        super(client_Connect_Form, self).__init__(parent)
        self.setupUi(self)
        #Center the window
        qr = self.frameGeometry()
        cp = QtWidgets.QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())
        
        self.setWindowTitle("ChainSpoT")
        self.setWindowIcon(QtGui.QIcon("Icons/logo.png"))
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        self.oldPos = self.pos()
        self.setWindowFlag(Qt.FramelessWindowHint) #Hide the title bar of window
        movie = QtGui.QMovie("Icons/loading1.gif") # Create a QMovie from our gif
        self.label.setMovie(movie) # use setMovie function in our QLabel
        movie.start() # now start the gif
        self.label_22.setText(str(room_ID))
        self.pushButton_5.clicked.connect(self.cancel)

        self.stop_threads=False
        
        t3 = Thread(target = self.interface_scan, args = () )
        t3.start()

        t2 = Thread(target = self.try_connect, args = () )
        t2.start()

        self.wifi_connect=""
        self.disconnect_wifi()
        self.Bold_font = QtGui.QFont()
        self.Bold_font.setBold(True)
        self.Normal_font = QtGui.QFont()
        self.Normal_font.setBold(False)
         #chain_show    trying_show   failed_show     connected_show
        self.chain_show_signal.connect(self.chain_show)
        self.trying_show_signal.connect(self.trying_show)
        self.failed_show_signal.connect(self.failed_show)
        self.connected_show_signal.connect(self.connected_show)
        

        

    def mousePressEvent(self, event):
        self.oldPos = event.globalPos()

    def mouseMoveEvent(self, event):
        delta = QPoint (event.globalPos() - self.oldPos)
        self.move(self.x() + delta.x(), self.y() + delta.y())
        self.oldPos = event.globalPos()

    def cancel(self):
        self.stop_threads=True
        self.disconnect_wifi()
        self.w = Client.client_Form("","disconnect" ,self.room_ID,self.password)
        self.w.show()
        self.close()

    def chain_show(self,sorted_ip,power):
        self.tableWidget.clearContents()
        self.tableWidget.setRowCount(0)
        self.tableWidget.setRowCount(len(sorted_ip))
        for i in range(len(sorted_ip)):
                self.tableWidget.setItem(i, 0, QtWidgets.QTableWidgetItem(sorted_ip[i]))
                self.tableWidget.item(i, 0).setTextAlignment(Qt.AlignCenter)
                self.tableWidget.setItem(i, 1, QtWidgets.QTableWidgetItem(sorted_ip[i].split('.')[2]))
                self.tableWidget.item(i, 1).setTextAlignment(Qt.AlignCenter)
                self.tableWidget.setItem(i, 2, QtWidgets.QTableWidgetItem(str(power[sorted_ip[i]])+"%" ))
                self.tableWidget.item(i, 2).setTextAlignment(Qt.AlignCenter)
        
    def trying_show(self,index):
        self.tableWidget.setItem(index, 3,QtWidgets.QTableWidgetItem("Trying..."))
        self.tableWidget.item(index,    3).setTextAlignment(Qt.AlignCenter)
        self.tableWidget.item(index,    1).setFont(self.Bold_font)
        self.tableWidget.item(index,    2).setFont(self.Bold_font)
        self.tableWidget.item(index,    3).setFont(self.Bold_font)
        
        
    def failed_show(self,index):
        self.tableWidget.item(index,    0).setFont(self.Normal_font)
        self.tableWidget.item(index,    1).setFont(self.Normal_font)
        self.tableWidget.item(index,    2).setFont(self.Normal_font)
        self.tableWidget.setItem(index, 3, QtWidgets.QTableWidgetItem("Failed"))
        self.tableWidget.item(index,    3).setFont(self.Bold_font)
        self.tableWidget.item(index,    3).setTextAlignment(Qt.AlignCenter)
        self.tableWidget.item(index,    3).setBackground(QtGui.QColor(138, 11, 49))

    def connected_show(self,index):
        self.tableWidget.setItem(index, 3, QtWidgets.QTableWidgetItem("Connected"))
        self.tableWidget.item(index,    3).setFont(self.Bold_font)                                       
        self.tableWidget.item(index,    3).setTextAlignment(Qt.AlignCenter)
        self.tableWidget.item(index,    3).setBackground(QtGui.QColor(50,205,50))
        QtTest.QTest.qWait(3000)
        self.w = Client.client_Form(self.wifi_connect,"connect" ,self.room_ID,self.password)
        self.w.show()
        self.close()

    def try_connect(self):   
        while True:
                if (self.stop_threads):
                        break
                power,id_list,room_list,comp_id =self.parse_wifi()
                sorted_ip = self.best_wifi_list(power,id_list)
                self.chain_show_signal.emit(sorted_ip,power)
                for wifi_try_connect in sorted_ip:
                        if (self.stop_threads):
                                break
                        self.trying_show_signal.emit(sorted_ip.index(wifi_try_connect))
                        if sorted_ip.index(wifi_try_connect) == 0 and power[wifi_try_connect] >= 50:
                                status = self.connect_wifi(wifi_try_connect)
                                if status:
                                        self.stop_threads=True          
                                        self.wifi_connect=wifi_try_connect
                                        self.connected_show_signal.emit(sorted_ip.index(wifi_try_connect))
                                        break
                                else:
                                        self.failed_show_signal.emit(sorted_ip.index(wifi_try_connect))        
                        elif power[wifi_try_connect] >= 60 :
                                status = self.connect_wifi(wifi_try_connect)
                                if status:
                                        self.stop_threads=True
                                        self.wifi_connect=wifi_try_connect
                                        self.connected_show_signal.emit(sorted_ip.index(wifi_try_connect))
                                        break
                                else:
                                        self.failed_show_signal.emit(sorted_ip.index(wifi_try_connect))
                        else:
                                self.failed_show_signal.emit(sorted_ip.index(wifi_try_connect))
                QtTest.QTest.qWait(2000)
                

    #first the function check if the profile wifi is save in this device or no , if no he will save it using save_profile()
    #eventually connect to wifi if it work return True else return False
    def connect_wifi(self,wifi):
        #other way
        #iface.connect(networks[wifi])
        prof = self.show_profiles()
        if prof:
                self.delete_profiles(prof)
                print(self.show_profiles())
        if self.save_profile(wifi):
                try:
                        cmd_output = subprocess.check_output('netsh wlan connect ssid="'+wifi+'" name="'+wifi+'"', shell=True).decode()
                        if "completed successfully" in cmd_output:
                                first_time=time.time()
                                while time.time()-first_time <= 20:
                                        QtTest.QTest.qWait(1000)
                                        
                                        if self.check_connect(wifi):
                                                return True
                except subprocess.CalledProcessError as e:
                        print(e.output)
                        return False
        return False

    def disconnect_wifi(self):
        try:
                cmd_output = subprocess.check_output("netsh wlan disconnect", shell=True).decode()
                if "completed successfully" in cmd_output:
                        return True
                else:
                        return False

        except subprocess.CalledProcessError as e:
                print(e.output)
                return -1


    #take wifi SSID as as parameter , check if it's connected or not and check it's signal power if it's more than 50% it'll return True , else return False
    def check_connect(self,wifi_connect):
        try:
                cmd_output = subprocess.check_output("ipconfig", shell=True).decode()
        except subprocess.CalledProcessError as e:
                print(e.output)
                return False
        if "Default Gateway" in cmd_output:
                try:
                        cmd_output = subprocess.check_output("Netsh WLAN show interfaces", shell=True).decode()
                except subprocess.CalledProcessError as e:
                        print(e.output)
                        return False
                if "SSID" in cmd_output:
                        cmd_output = cmd_output.replace("\r","")
                        list_output = cmd_output.split("\n")
                        
                        for i in list_output:
                                if "SSID                   :" in i:
                                        wifi_name =i.split(":")[1][1:]
                                        
                                if "Signal                 :" in i:
                                        wifi_power =int(i.split(":")[1][1:].replace("%",""))
                                        

                        if wifi_name == wifi_connect and wifi_power >=50 and "connected" in cmd_output:
                                return True
    
        return False

    #to connect any wifi network you must save its profile
    #this function creat xml file and save it to windows and delete the file after save it
    #work for only WPA2PSK wifi
    #input wifi SSID , wifi passwkord
    def save_profile(self,wifi):
        xml_file = '''<?xml version="1.0"?>
<WLANProfile xmlns="http://www.microsoft.com/networking/WLAN/profile/v1">
	<name>'''+wifi+'''</name>
	<SSIDConfig>
		<SSID>
			<hex>'''+str(wifi.encode().hex()).upper()+'''</hex>
			<name>'''+wifi+'''</name>
		</SSID>
	</SSIDConfig>
	<connectionType>ESS</connectionType>
	<connectionMode>auto</connectionMode>
	<MSM>
		<security>
			<authEncryption>
				<authentication>WPA2PSK</authentication>
				<encryption>AES</encryption>
				<useOneX>false</useOneX>
			</authEncryption>
			<sharedKey>
				<keyType>passPhrase</keyType>
				<protected>false</protected>
				<keyMaterial>'''+self.password+'''</keyMaterial>
			</sharedKey>
		</security>
	</MSM>
	<MacRandomization xmlns="http://www.microsoft.com/networking/WLAN/profile/v3">
		<enableRandomization>false</enableRandomization>
	</MacRandomization>
</WLANProfile>
'''
        with open("wifi.xml","w") as file:
                file.write(xml_file)
        cwd = os.getcwd()
        try:
                cmd_output = subprocess.check_output('netsh wlan add profile filename="'+cwd+"\wifi.xml" + '" user=all', shell=True).decode()
        except subprocess.CalledProcessError as e:
                print(e.output)
                return False
        try:
                os.remove(cwd+"\wifi.xml")
        except:
                pass
        if "is added" in cmd_output:
                try:
                        out = subprocess.check_output('netsh wlan set profileparameter name='+wifi+' connectionmode=auto', shell=True).decode()
                except subprocess.CalledProcessError as e:
                        print(e.output)
                        return False
                if "updated successfully." in out:
                        out=out.split(" ")
                        interface=out[4]
                        try:
                                subprocess.check_output('netsh wlan set profileorder name='+wifi+' interface='+interface+' priority=1', shell=True)
                        except subprocess.CalledProcessError as e:
                                print(e.output)
                                return False
                return True
        return False

                    
    #it's connect to the best chosse of spot ID list , it's need to id_list from parse_wifi() and take room ID and Password from the user
    def best_wifi_list(self,power,id_list):
        sorted_ip=[]
        s = re.compile(str(self.room_ID)+".\d+\.\d+")
        sorted_ip = list(filter(s.match, id_list))
        sorted_ip=sorted(sorted_ip,key=lambda t:(int(t.split('.')[2]),-power[t],int(t.split('.')[1]))) #Priority in sorting to hub to reduce hubs As much as possible
        #Second priority for the signal power To maintain network stability
        return sorted_ip


     #it's return list of spot ID which contain rooms and computer ID return
    def parse_wifi(self):
        power=self.power_wifi()
        networks= list(power.keys())
        r = re.compile("\d+\.\d+\.\d+")
        id_list = list(filter(r.match, networks))
        room_list = []
        comp_id=[]
        if id_list: #Bug we can remove "if id_list" for loop will do this check for us 
           for i in id_list:
              room_list.append(int(i.split(".")[0]))
              comp_id.append(int(i.split(".")[1]))
        return power , id_list, sorted(room_list) , sorted(comp_id)

    #return dictionary {key:value} key is network SSID , value is percentage of SSID Power ex: 30,70,80,99
    def power_wifi(self,power = {},prev_check=0):
        if prev_check==0:
                power = {}
        try:
                cmd_output = subprocess.check_output("netsh wlan SHOW NETWORKS MODE=BSSID", shell=True)
        except subprocess.CalledProcessError as e:
                print(e.output)
                return power
        cmd_output = cmd_output.decode("utf-8")
        cmd_output = cmd_output.replace("\r","")
        list_output = cmd_output.split("\n")
        list_output = list_output[4:]
        count = 0
        while count < len(list_output):
           if "SSID" in list_output[count] and list_output[count][9:].strip() != ""  :
                #Bug count + 5 list index out of range when connecting to wifi Signal element not exist
                try:
                   if "Signal" in list_output[count+5]:     
                        power[list_output[count][9:].strip()]=int(''.join(list(filter(str.isdigit, list_output[count+5]))))
                except:
                   pass
           count += 1
        if  prev_check == 0 :          
                QtTest.QTest.qWait(4000)
                return self.power_wifi(power,1)   
        else:
                print(power)
                return power

    # "netsh wlan SHOW NETWORKS" command not actually re-scan the available wifi networks , it's just show the cash of the last scanning operation
    #in this function we re-scan the wifi interface by pywifi library   Interface.scan()
    def interface_scan(self):
        wifi = pywifi.PyWiFi()
        iface = wifi.interfaces()[0]
        while True:
                if (self.stop_threads):
                        break
                print("i2")
                iface.scan()
                time.sleep(6)
        

    #return list of saved profiles
    #if there's not saved profiles , it'll return False
    def show_profiles(self):
        try:
                cmd_output = subprocess.check_output("netsh wlan show profiles", shell=True).decode()
        except subprocess.CalledProcessError as e:
                print(e.output)
                return False
        cmd_output = cmd_output.replace("\r","")
        cmd_output = cmd_output.split("\n")
        list_output=[]
        for i in cmd_output:
                if ":" in i:
                        list_output.append(i.split(":")[1][1:])
        if list_output:
                return list_output[1:]
        return False

    #take list of profiles (which you want to delete) as parameter and delete them
    def delete_profiles(self,profiles):
        r = re.compile("\d+\.\d+\.\d+")
        profiles = list(filter(r.match, profiles))
        for i in profiles:
                try:
                        cmd_output = subprocess.check_output('netsh wlan delete profile name="'+i+'"', shell=True).decode()
                except subprocess.CalledProcessError as e:
                        print(e.output)


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    client = client_Connect_Form()
    client.show()
    sys.exit(app.exec_())