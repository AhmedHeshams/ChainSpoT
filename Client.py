# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Client.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from threading import Thread

from PyQt5 import QtCore, QtGui, QtWidgets,QtTest
from PyQt5.QtCore import Qt , QPoint,pyqtSignal 
import Master_or_Client
import subprocess
import re
import pywifi
import Client_Connect
import time
import Client_GUI
import socket
import json
from graphviz import Digraph
import os
import shutil
import random
from PIL import Image

class client_Form(QtWidgets.QWidget, Client_GUI.Ui_Form_client):
    forward_signal         = pyqtSignal()
    tree_show_signal       = pyqtSignal()
    clear_text_signal      = pyqtSignal()
    chat_show_signal       = pyqtSignal(str)
    room_show_signal       = pyqtSignal(str)
    program_state_signal   = pyqtSignal(str)
    state_change_signal    = pyqtSignal(str)
    hotspot_state_signal   = pyqtSignal(str)
    def __init__(self,wifi_connect="",state="", room_ID="",password="" ,parent=None):
        super(client_Form, self).__init__(parent)
        self.setWindowTitle("ChainSpoT")
        self.setWindowIcon(QtGui.QIcon("Icons/logo.png"))
        self.wifi_connect= wifi_connect
        self.state    = state
        self.room_ID  = room_ID
        self.password = password
         
        self.setupUi(self)
        #Center the window
        qr = self.frameGeometry()
        cp = QtWidgets.QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        self.oldPos = self.pos()
        self.setWindowFlag(Qt.FramelessWindowHint) #Hide the title bar of window
        self.pushButton_6.clicked.connect(self.master_or_client)
        self.bn_close.clicked.connect(self.exit)
        self.bn_min.clicked.connect(self.showMinimized)
        self.checkBox_2.toggled.connect(self.show_hide_pass)
        self.pushButton_3.hide()
        self.pushButton_7.hide()
        self.pushButton.clicked.connect(self.connect)
        self.pushButton_2.clicked.connect(self.disconnect)
        self.Master.setTabEnabled(1,False)
        self.Master.setTabEnabled(2,False)
        self.Master.setTabEnabled(3,False)
        self.pushButton_4.clicked.connect(self.on_enter_key_pressed)
        self.plainTextEdit_2.installEventFilter(self)
        
        self.stop_threads = False
        t4 = Thread(target = self.interface_scan, args = () )
        t4.start()

        
        t1 = Thread(target = self.check, args = () )
        t1.start()
        if(self.wifi_connect != "" and self.state =="connect" and self.check_connect(self.wifi_connect)):
                t_client = Thread(target = self.client_run, args = () )
                t_client.start()        
        
        self.profile_name=""
        self.hotspot_name=""
        self.lineEdit_2.setText(str(room_ID))
        self.lineEdit.setText(str(password))
        self.forward_signal.connect(self.open_client_conn)
        self.tree_show_signal.connect(self.tree_show)
        self.chat_show_signal.connect(self.chat_show)
        self.clear_text_signal.connect(self.clear_text)
        self.room_show_signal.connect(self.room_show)
        self.program_state_signal.connect(self.program_state)
        self.state_change_signal.connect(self.state_change)
        self.hotspot_state_signal.connect(self.hotspot_state)
        self.tree=[]

#########################################Client Mangement###############################################################################
    def client_run(self):
        self.initialize_socket()
        self.listen_for_incoming_messages_in_a_thread()
        self.on_join()
        
        
    def initialize_socket(self):
        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # initialazing socket with TCP and IPv4
        remote_ip = '192.168.0.2' # IP address 
        remote_port = 10319 #TCP port
        self.client_socket.connect((remote_ip, remote_port)) #connect to the remote server


    def listen_for_incoming_messages_in_a_thread(self):
        thread = Thread(target=self.receive_message_from_server, args=(self.client_socket,)) # Create a thread for the send and receive in same time 
        thread.start()
        
    #function to recieve msg
    def receive_message_from_server(self, so):
        buffer=""
        while True:
            try:
                buffer = so.recv(1024)
            except Exception as e: # socket.error as e:    
                if "An established connection was aborted by the software in your host machine" in str(e) or "An existing connection was forcibly closed by the remote host" in str(e) :
                        self.tree_thread_stop = 1
                        return
                else:
                        print("new")
                        print(e)
                        
            if not buffer:
                break
            message = buffer.decode('utf-8')
            if '{"parent": 'in message:
                message = json.loads(message)
                self.add_to_tree(message)
                continue
            if "joined" in message:
                user = message.split(":")[1]
                message = user + " has joined"

            self.chat_show_signal.emit(message)
        so.close()

    def on_join(self):
        #put hotspot name
        while (True):
            if(self.hotspot_name!=""):
                break
  
        self.client_socket.send(("joined:" + self.hotspot_name).encode('utf-8'))
        
        self.tree_thread_stop = 0
        tree_thread = Thread(target=self.tree_send, args=()) # Create a thread for the send and receive in same time 
        tree_thread.start()

    def eventFilter(self, obj, event):
        if obj is self.plainTextEdit_2 and event.type() == QtCore.QEvent.KeyPress:
            modifiers = QtWidgets.QApplication.keyboardModifiers()
            if modifiers != QtCore.Qt.ShiftModifier: #This condition to prevent Shift + Enter from sending messages, it will just make new line and move cursor to it (The normal case)
                if event.key() in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter):
                    self.on_enter_key_pressed()
                    return True
        return super(client_Form, self).eventFilter(obj, event)

    def on_enter_key_pressed(self):
        self.send_chat()
        self.clear_text_signal.emit()

    def clear_text(self):
        self.plainTextEdit_2.setPlainText("")

    def send_chat(self):
        senders_name = self.hotspot_name + ": "
        data = self.plainTextEdit_2.toPlainText().strip()
        message = (senders_name + data).encode('utf-8')
        self.client_socket.send(message)
        self.chat_show_signal.emit(message.decode('utf-8'))
        return 'break'
 
    def mov_bin(self):
        cwd = os.getcwd()
        mwd = os.path.join(cwd, "Graphviz","bin")
        allfiles = os.listdir(mwd)
        for file in allfiles:
            shutil.copy(os.path.join(mwd,file),os.path.join(cwd,file))
        return allfiles

    def delete_bin(self,allfiles):   
        for file in allfiles:
            if os.path.exists(file):
                os.remove(file)

    def add_to_tree(self, leaf):
        for i in self.tree:
            if i["hotspot_name"] == leaf["hotspot_name"]:
                self.tree.remove(i)
        self.tree.append(leaf)

    def room_show(self,rooms):
        if self.stop_threads == 0:
            self.label_26.setText(rooms)

    def chat_show(self,message):
        self.plainTextEdit.insertPlainText(message + '\n')
        scrollIsAtEnd = self.plainTextEdit.verticalScrollBar().maximum() - self.plainTextEdit.verticalScrollBar().value()
        if (scrollIsAtEnd):
            self.plainTextEdit.verticalScrollBar().setValue(self.plainTextEdit.verticalScrollBar().maximum())

    def tree_show(self):
        self.tree_photo.setAlignment(Qt.AlignCenter)
        self.statistics_photo.setAlignment(Qt.AlignCenter)
        self.tree_photo.setPixmap(QtGui.QPixmap("tree.png"))
        self.statistics_photo.setPixmap(QtGui.QPixmap("statistics.png"))

    def tree_send(self):
        while True:
                if self.tree_thread_stop == 1:
                        break
                time_now = int(time.time())
                for i in self.tree:
                    if time_now - int(i["time"]) > 100:
                        self.tree.remove(i)

                try:
                    cmd_output = subprocess.check_output("ping 192.168.0.2", shell=True).decode()
                    loss_regex = re.compile(r'\d+%')
                    temp       = loss_regex.search(cmd_output)
                    loss       = temp.group()
                    cmd_output = cmd_output.split("\n")[-2]
                    if "Average" in cmd_output:
                        cmd_output = cmd_output.replace("\r","")
                        cmd_output = cmd_output.replace(" ","")
                        cmd_output = cmd_output.split("=")
                        ping       = cmd_output[-1]
                    else:
                        ping       = ""
                        loss       = "100%"
                except subprocess.CalledProcessError as e:
                    print(e.output)
                    ping       = "error"
                    loss       = "error"
                
                try:
                    cmd_output = subprocess.check_output("ipconfig", shell=True).decode().split("Wireless LAN adapter Wi-Fi:\r\n\r\n   ")[1].replace("\r","").split("\n")
                    for i in cmd_output:
                            if i == "":
                                    wifi_ip =socket.gethostbyname(socket.gethostname())
                                    break        
                            elif "IPv4 Address" in i:
                                    wifi_ip=i.split(" ")[-1]
                                    break
                except subprocess.CalledProcessError as e:
                    print(e.output)
                    wifi_ip =socket.gethostbyname(socket.gethostname())
                if self.tree_thread_stop == 1:
                        break
                myleaf ={
                "parent": self.wifi_connect,
                "wifi_ip": wifi_ip,
                "hotspot_name": self.hotspot_name,
                "loss":loss,
                "ping": ping,
                "time":str(int(time.time()))
                }
                
                data = json.dumps(myleaf)
                self.add_to_tree(myleaf)
                # instantiating object
                dot_tree = Digraph(comment='A Round Graph')
                dot_statistics = Digraph(comment='A Round Graph')
                for key in self.tree:
                    dot_tree.node(str(self.tree.index(key) ),key["hotspot_name"])
                    dot_statistics.node(str(self.tree.index(key) ),"Node name: "+key["hotspot_name"]+"\nNode IP: "+key["wifi_ip"]+"\nLoss "+key["loss"]+"\nPing "+key["ping"])


                # Adding edges
                a = []
                for key in self.tree:
                    for i in self.tree:
                        if key["parent"] == i["hotspot_name"]:
                            a.append(f'{self.tree.index(i)}{self.tree.index(key)}')
                print(self.tree)
                self.tree = []
                dot_tree.edges(a)
                dot_statistics.edges(a)

                # saving images
                dot_tree.format = 'png'
                dot_statistics.format = 'png'
                allfiles = self.mov_bin()
                dot_tree.render("tree", view = False)
                dot_statistics.render("statistics", view = False)
                image = Image.open("statistics.png")
                temp  = image.resize((900,350))
                temp.save("statistics.png")
                self.tree_show_signal.emit()
                self.delete_bin(allfiles)
                self.client_socket.send(bytes(data,encoding="utf-8"))
                
                time.sleep(50)


########################################################################################################################################
    

    def program_state(self,txt):
        self.label_15.setText(txt)
    
    def hotspot_state(self,hotspot_name):
        self.label_19.setText(hotspot_name)
        self.lab_user.setText(hotspot_name)

    def state_change(self,wifi_connect):
        if wifi_connect =="":
            self.lab_user_2.setStyleSheet("color:rgb(138, 11, 49);")
            self.lab_user_2.setText("Disconnect")
            self.label_22.setText("Disconnect")
            self.label_17.setText(wifi_connect)
            self.pushButton_3.hide()
            self.pushButton_7.hide()
            self.pushButton.setEnabled(True)
            self.pushButton_2.setEnabled(False)
            self.Master.setTabEnabled(1,False)
            self.Master.setTabEnabled(2,False)
            self.Master.setTabEnabled(3,False)
        else:
            self.lab_user_2.setStyleSheet("color:rgb(50,205,50);")
            self.lab_user_2.setText("Connect")
            self.label_22.setText("Connect")
            self.label_17.setText(wifi_connect)
            self.pushButton_3.show()
            self.pushButton_7.show()
            self.pushButton.setEnabled(False)
            self.pushButton_2.setEnabled(True)
            self.Master.setTabEnabled(1,True)
            self.Master.setTabEnabled(2,True)
            self.Master.setTabEnabled(3,True)

    def check(self):
        while True:
                power,id_list,room_list,comp_id =self.parse_wifi()
                if (self.stop_threads):
                        break
                self.room_show_signal.emit(str( list(dict.fromkeys(room_list)) ).replace(","," , ").replace("[","").replace("]",""))                
            
                if (self.wifi_connect == "" and (self.state =="" or self.state =="disconnect")):
                        self.state_change_signal.emit("")
                        
                elif(self.wifi_connect != "" and self.state =="connect" and self.check_connect(self.wifi_connect)):
                        self.state_change_signal.emit(self.wifi_connect)

                        if self.check_hotspot() == True:
                                self.program_state_signal.emit("                            ChainSpoT Hotspot Still Up")
                        else:
                                if self.wifi_connect != "":
                                        self.program_state_signal.emit("                      Trying To Start ChainSpoT Hotspot ...")
                                        power,id_list,room_list,comp_id_just_in_case =self.parse_wifi()
                                        comp_id = comp_id + comp_id_just_in_case
                                        while True:
                                            my_comp_id = random.randint(1, 999)
                                            if my_comp_id not in comp_id:
                                                break
                                        self.hotspot_name = self.room_ID +"."+str(my_comp_id)+"."+str(int(self.wifi_connect.split(".")[2])+1)
                                                
                                        check=self.start_hotspot(self.hotspot_name,self.password)
                                                
                                        if check and self.check_hotspot() == True:
                                                self.hotspot_state_signal.emit(self.hotspot_name)
                                                self.program_state_signal.emit("                     ChainSpoT Hotspot Start Successfully")
                                        else:
                                                self.program_state_signal.emit("                      Failed To Start ChainSpoT Hotspot")

                elif(self.wifi_connect != "" and self.state =="connect"):
                    self.wifi_connect =""
                    self.stop_threads= True
                    try:
                        self.client_socket.close()
                    except socket.error as e:
                        print("close after change")
                        print(e)
                    self.forward_signal.emit()
                    break               
                
                time.sleep(7)
        


  
    def open_client_conn(self):
            self.w = Client_Connect.client_Connect_Form(self.lineEdit_2.text(),self.lineEdit.text())
            self.w.show()
            self.close()
            
    #take wifi SSID as as parameter , check if it's connected or not and check it's signal power if it's more than 50% it'll return True , else return False
    def check_connect(self,wifi_connect):
        try:
            cmd_output = subprocess.check_output("ipconfig", shell=True).decode()
        except subprocess.CalledProcessError as e:
            print(e.output)
            return False
        if "Default Gateway" in cmd_output:
                try:
                    cmd_output = subprocess.check_output("Netsh WLAN show interfaces", shell=True).decode()
                except subprocess.CalledProcessError as e:
                    print(e.output)
                    return False
                if "SSID" in cmd_output:
                        cmd_output = cmd_output.replace("\r","")
                        list_output = cmd_output.split("\n")
                        for i in list_output:
                                if "SSID                   :" in i:
                                        wifi_name =i.split(":")[1][1:]
                                if "Signal                 :" in i:
                                        wifi_power =int(i.split(":")[1][1:].replace("%",""))

                        if wifi_name == wifi_connect and wifi_power >=50 and "connected" in cmd_output:
                                return True
        return False
    #it's return list of spot ID which contain rooms and computer ID return
    def parse_wifi(self):
        power=self.power_wifi()
        networks= list(power.keys())
        r = re.compile("\d+\.\d+\.\d+")
        id_list = list(filter(r.match, networks))
        room_list = []
        comp_id=[]
        if id_list: #Bug we can remove "if id_list" for loop will do this check for us 
           for i in id_list:
              room_list.append(int(i.split(".")[0]))
              comp_id.append(int(i.split(".")[1]))
        return power , id_list, sorted(room_list) , sorted(comp_id)

    #return dictionary {key:value} key is network SSID , value is percentage of SSID Power ex: 30,70,80,99
    def power_wifi(self,power = {},prev_check=0):
        if prev_check==0:
                power = {}
        try:
            cmd_output = subprocess.check_output("netsh wlan SHOW NETWORKS MODE=BSSID", shell=True)
        except subprocess.CalledProcessError as e:
            print(e.output)
            return power

        cmd_output = cmd_output.decode()
        cmd_output = cmd_output.replace("\r","")
        list_output = cmd_output.split("\n")
        list_output = list_output[4:]
        count = 0
        while count < len(list_output):
           if "SSID" in list_output[count] and list_output[count][9:].strip() != ""  :
                #Bug count + 5 list index out of range when connecting to wifi Signal element not exist
                try:
                   if "Signal" in list_output[count+5]:     
                        power[list_output[count][9:].strip()]=int(''.join(list(filter(str.isdigit, list_output[count+5]))))
                except:
                   pass
           count += 1
        if  prev_check == 0 :          
                QtTest.QTest.qWait(4000)
                return self.power_wifi(power,1)   
        else:
                return power

    # "netsh wlan SHOW NETWORKS" command not actually re-scan the available wifi networks , it's just show the cash of the last scanning operation
    #in this function we re-scan the wifi interface by pywifi library   Interface.scan()
    def interface_scan(self):
        wifi = pywifi.PyWiFi()
        iface = wifi.interfaces()[0]
        while True:
                if (self.stop_threads):
                        break
                print("i1")
                iface.scan()
                time.sleep(6)

    

    def disconnect_wifi(self):
        try:
                cmd_output = subprocess.check_output("netsh wlan disconnect", shell=True).decode()
                if "completed successfully" in cmd_output:
                        return True
                        
                else:
                        return False

        except subprocess.CalledProcessError as e:
                print(e.output)
                return -1
   

    def run(self,cmd):
        try:
            self.completed =subprocess.run(["powershell", "-Command", cmd], capture_output=True)
        except subprocess.CalledProcessError as e:
            print(e.output)
            return -1
        return self.completed

    #check if you open hotspot or not return True or False
    def check_hotspot(self,prev_check=0):
       if self.profile_name =="":
               return -1
       power_shell_cmd='''$connectionProfile = [Windows.Networking.Connectivity.NetworkInformation,Windows.Networking.Connectivity,ContentType=WindowsRuntime]::GetConnectionProfiles()
foreach($i in $connectionProfile){
if ( $i.profileName -eq ''' +"'" +self.profile_name+ "'"+''' )
{
$profileName =$i 
}
}
$tetheringManager = [Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager,Windows.Networking.NetworkOperators,ContentType=WindowsRuntime]::CreateFromConnectionProfile($profileName)
$tetheringManager.TetheringOperationalState
    '''
       power_shell_output = self.run(power_shell_cmd)
       power_shell_output = power_shell_output.stdout.decode()
       power_shell_output = power_shell_output.replace("\r","")
       power_shell_output = power_shell_output.replace("\n","")
     
       if power_shell_output =="InTransition" and prev_check == 0 :
          QtTest.QTest.qWait(5000)
          return self.check_hotspot(1) 
       elif power_shell_output == "On":
          return True
       elif power_shell_output == "Off":
          return False
       else:
          return -1

    #start hotspot networf if it works return True else return False
    #input only hotspot name and password of hotspot
    def start_hotspot(self,hotspot_name,password):

       if len(password) <8 or len(password) > 32 or'"' in password: #If password less than 8 char or bigger than 32 char or there's double quote in password retturn -1
                return -1

       self.power_shell_cmd= '''Add-Type -AssemblyName System.Runtime.WindowsRuntime
$asTaskGeneric = ([System.WindowsRuntimeSystemExtensions].GetMethods() | ? { $_.Name -eq 'AsTask' -and $_.GetParameters().Count -eq 1 -and $_.GetParameters()[0].ParameterType.Name -eq 'IAsyncOperation`1' })[0]
Function Await($WinRtTask, $ResultType) {
    $asTask = $asTaskGeneric.MakeGenericMethod($ResultType)
    $netTask = $asTask.Invoke($null, @($WinRtTask))
    $netTask.Wait(-1) | Out-Null
    $netTask.Result
}
Function AwaitAction($WinRtAction) {
    $asTask = ([System.WindowsRuntimeSystemExtensions].GetMethods() | ? { $_.Name -eq 'AsTask' -and $_.GetParameters().Count -eq 1 -and !$_.IsGenericMethod })[0]
    $netTask = $asTask.Invoke($null, @($WinRtAction))
    $netTask.Wait(-1) | Out-Null
}
$connectionProfile = [Windows.Networking.Connectivity.NetworkInformation,Windows.Networking.Connectivity,ContentType=WindowsRuntime]::GetConnectionProfiles()
foreach($i in $connectionProfile){
$randomProfile =$i  
}
$tetheringManager = [Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager,Windows.Networking.NetworkOperators,ContentType=WindowsRuntime]::CreateFromConnectionProfile($randomProfile)
$accessPointConfiguration = $tetheringManager.GetCurrentAccessPointConfiguration()
$accessPointConfiguration.Ssid = ''' + '"'+ hotspot_name+'"'+" \n$accessPointConfiguration.Passphrase ="+'"'+password+'"' +''' \nAwaitAction ($tetheringManager.ConfigureAccessPointAsync($accessPointConfiguration)) ([Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult])
Await ($tetheringManager.StartTetheringAsync()) ([Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult])
Write-Output $randomProfile.profileName
'''
   
       self.power_shell_output = self.run(self.power_shell_cmd)
       
       if self.power_shell_output.returncode != 0:
                #print("An error occured: %s", completed.stderr) # Just if You want to print the error
                return False

       self.power_shell_output = self.power_shell_output.stdout.decode()
       self.power_shell_output = self.power_shell_output.replace("\r","")
       self.power_shell_output = self.power_shell_output.split("\n")
  
       for i in range(len(self.power_shell_output)):
               if "Success" in self.power_shell_output[i]:
                       self.profile_name=self.power_shell_output[i+1]
                       return True
       return False

    #check if you open hotspot or not then stop hotspot network if it done return True else return False
    #input only hotspot name and password of hotspot
    def stop_hotspot(self):
       if self.profile_name =="":
               return -1
       power_shell_cmd='''$connectionProfile = [Windows.Networking.Connectivity.NetworkInformation,Windows.Networking.Connectivity,ContentType=WindowsRuntime]::GetConnectionProfiles()
foreach($i in $connectionProfile){
if ( $i.profileName -eq ''' +"'" +self.profile_name+ "'"+''' )
{
$profileName =$i 
}
}       
$tetheringManager = [Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager,Windows.Networking.NetworkOperators,ContentType=WindowsRuntime]::CreateFromConnectionProfile($profileName)
$tetheringManager.StopTetheringAsync()
'''
       power_shell_output = self.run(power_shell_cmd)
       check = self.check_hotspot()
       if check == False:
        return True 
       elif check == True:
        return False
       else:
        return -1

        

    def connect(self):
        self.stop_threads=True
        #self.interface_timer.stop()
        #self.timer_check.stop()
        self.state="connect"
        self.w = Client_Connect.client_Connect_Form(self.lineEdit_2.text(),self.lineEdit.text())
        self.w.show()
        self.close()



    def disconnect(self):
        self.state="disconnect"
        self.label_15.setText("                     Trying To Stop ChainSpoT Network ...")
        check_hotspot = self.stop_hotspot()
        check_wifi = self.disconnect_wifi()
        if check_hotspot  and check_wifi and  self.check_hotspot() == False and self.check_connect(self.wifi_connect) == False:
                self.label_15.setText("                    ChainSpoT Network Stop Successfully")
                self.lab_user.setText("")
                self.lab_user_2.setStyleSheet("color:rgb(138, 11, 49);")
                self.lab_user_2.setText("OFF")
                self.label_22.setText("OFF")
                self.label_17.setText("")
                self.label_19.setText("")
                self.pushButton_3.hide()
                self.pushButton_7.hide()
                self.pushButton.setEnabled(True)
                self.pushButton_2.setEnabled(False)
                self.Master.setTabEnabled(1,False)
                self.Master.setTabEnabled(2,False)
                self.Master.setTabEnabled(3,False)
                self.client_socket.close()
        else:
                self.label_15.setText("                      Failed To Stop ChainSpoT Network")




    def show_hide_pass(self):
        if self.checkBox_2.isChecked():
                self.lineEdit.setEchoMode(QtWidgets.QLineEdit.Normal)
        else:
                self.lineEdit.setEchoMode(QtWidgets.QLineEdit.Password)
        
    def exit(self):
        self.stop_threads=True
        self.close()

    def master_or_client(self):
        self.stop_threads=True
        self.w = Master_or_Client.master_or_client_Form()
        self.w.show()
        self.close()

    def mousePressEvent(self, event):
        self.oldPos = event.globalPos()

    def mouseMoveEvent(self, event):
        delta = QPoint (event.globalPos() - self.oldPos)
        self.move(self.x() + delta.x(), self.y() + delta.y())
        self.oldPos = event.globalPos()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    client = client_Form()
    client.show()
    sys.exit(app.exec_())
